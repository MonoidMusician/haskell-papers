[[0,{"references":[],"title":"A framework for adaptive differential privacy","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110254"]}],[1,{"references":[],"title":"A fully concurrent garbage collector for functional programs on multicore processors","links":["http://www.pllab.riec.tohoku.ac.jp/papers/icfp2016UenoOhori-preprint.pdf"]}],[2,{"references":[],"title":"A glimpse of Hopjs","links":["https://hal.inria.fr/hal-01350936/document"]}],[3,{"references":[],"title":"A history of Haskell: being lazy with class","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf"]}],[4,{"references":[],"title":"A lambda-calculus foundation for universal probabilistic programming","links":["https://pps2016.soic.indiana.edu/files/2016/01/lcfupp.pdf"]}],[5,{"references":[],"title":"A metaprogramming framework for formal verification","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110278"]}],[6,{"references":[],"title":"A natural semantics for tracing in Haskell","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[8,{"references":[],"title":"A new verified compiler backend for CakeML","links":["https://cakeml.org/icfp16.pdf"]}],[7,{"references":[],"title":"A pretty but not greedy printer","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110250"]}],[85,{"references":[],"title":"A reflection on types","links":[]}],[9,{"references":[],"title":"A relational logic for higher-order programs","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110265"]}],[86,{"references":[],"title":"A safe dialect of C","links":[]}],[10,{"references":[],"title":"A specification for dependent types in Haskell","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110275"]}],[11,{"references":[],"title":"A static checker for safe pattern matching in Haskell","links":["https://ndmitchell.com/downloads/paper-a_static_checker_for_safe_pattern_matching_in_haskell-01_feb_2007.pdf"]}],[12,{"references":[],"title":"A supercompiler for Core Haskell","links":["https://ndmitchell.com/downloads/paper-a_supercompiler_for_core_haskell-01_may_2008.pdf"]}],[87,{"references":[],"title":"A transformation-based optimiser for Haskell","links":[]}],[13,{"references":[],"title":"A type theory for incremental computational complexity with control flow changes","links":["https://people.mpi-sws.org/~ecicek/DuCostIt.pdf"]}],[14,{"references":[],"title":"A unified approach to solving seven programming problems","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110252"]}],[15,{"references":[],"title":"Abstracting definitional interpreters","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110256"]}],[16,{"references":[],"title":"Accelerating Haskell array codes with multicore GPUs","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-cuda-damp2011.pdf"]}],[17,{"references":[],"title":"All sorts of permutations","links":["https://www.informatik.uni-kiel.de//~sad/icfp2016-preprint.pdf"]}],[18,{"references":[],"title":"Allocation characterizes polyvariance: a unified methodology for polyvariant control-flow analysis","links":["https://thomas.gilray.org/pdf/allocation-polyvariance.pdf"]}],[19,{"references":[],"title":"An abstract memory functor for verified C static analyzers","links":["https://hal.inria.fr/hal-01339969/document"]}],[20,{"references":[],"title":"Automatically disproving fair termination of higher-order functional programs","links":[]}],[88,{"references":[],"title":"Automating ad hoc representation transformations","links":[]}],[21,{"references":[],"title":"Automating sized-type inference for complexity analysis","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110287"]}],[22,{"references":[],"title":"Better living through operational semantics: an optimizing compiler for radio protocols","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110263"]}],[23,{"references":[],"title":"Call arity","links":["https://www.joachim-breitner.de/publications/CallArity-TFP.pdf"]}],[89,{"references":[],"title":"Calling Hell from Heaven and Heaven from Hell","links":[]}],[24,{"references":[],"title":"Chaperone contracts for higher-order sessions","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110279"]}],[25,{"references":[],"title":"Combining effects and coeffects via grading","links":["https://www.cs.kent.ac.uk/people/staff/dao7/publ/combining-effects-and-coeffects-icfp16.pdf"]}],[26,{"references":[],"title":"Communicating Haskell processes: composable explicit concurrency using monads","links":["http://twistedsquare.com/CHP.pdf"]}],[27,{"references":[],"title":"Compact bit encoding schemes for simply-typed lambda-terms","links":[]}],[28,{"references":[],"title":"Compiling to categories","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110271"]}],[29,{"references":[],"title":"Compiling tree transforms to operate on packed representations","links":["http://drops.dagstuhl.de/opus/volltexte/2017/7273/pdf/LIPIcs-ECOOP-2017-26.pdf"]}],[30,{"references":[],"title":"Comprehending monads","links":["https://ncatlab.org/nlab/files/WadlerMonads.pdf"]}],[31,{"references":[],"title":"Constrained type families","links":["https://arxiv.org/pdf/1706.09715.pdf","https://dl.acm.org/citation.cfm?doid=3136534.3110286"]}],[32,{"references":[],"title":"Constructive Galois connections: taming the Galois connection framework for mechanized metatheory","links":["https://arxiv.org/pdf/1511.06965.pdf"]}],[33,{"references":[],"title":"Context-free session types","links":["https://www.di.fc.ul.pt/~vv/papers/thiemann.vasconcelos_context-free-session-types.pdf"]}],[34,{"references":[],"title":"Control flow in functional languages","links":["http://www.joachim-breitner.de/various/SA/ShiversStudienarbeit.pdf"]}],[35,{"references":[],"title":"Converting data-parallelism to tasl-parallelism by rewrites","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-multidev-fhpc2015.pdf"]}],[36,{"references":[],"title":"Dag-calculus: a calculus for parallel computation","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951946"]}],[37,{"references":[],"title":"Data flow fusion with series expressions in Haskell","links":["http://benl.ouroborus.net/papers/2013-series/flow-Haskell2013-rev1.pdf"]}],[38,{"references":[],"title":"Datafun: a functional Datalog","links":["https://www.cl.cam.ac.uk/~nk480/datafun.pdf"]}],[39,{"references":[],"title":"Dependent types in Haskell: theory and practice","links":["https://arxiv.org/pdf/1610.07978.pdf"]}],[40,{"references":[],"title":"Deriving a probability density calculator","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951922"]}],[41,{"references":[],"title":"Deriving a relationship from a single example","links":["https://ndmitchell.com/downloads/paper-deriving_a_relationship_from_a_single_example-04_sep_2009.pdf"]}],[42,{"references":[],"title":"Deriving generic functions by example","links":["https://ndmitchell.com/downloads/paper-deriving_generic_functions_by_example-26_oct_2007.pdf"]}],[43,{"references":[],"title":"Deriving program coverage from Hat traces","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[90,{"references":[],"title":"Design and implementation of generics for the .NET Common Language Runtime","links":[]}],[44,{"references":[],"title":"Disjoint intersection types","links":["http://i.cs.hku.hk/~bruno/papers/icfp2016.pdf"]}],[45,{"references":[],"title":"dup: explicit un-sharing in Haskell","links":["https://arxiv.org/pdf/1207.2017.pdf"]}],[46,{"references":[],"title":"Dynamic witnesses for static type errors (or, ill-typed programs usually go wrong)","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951915"]}],[47,{"references":[],"title":"Effect-driven QuickChecking of compilers","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110259"]}],[48,{"references":[49],"title":"Efficient communication and collection with compact normal forms","links":["http://ezyang.com/papers/ezyang15-cnf.pdf"]}],[50,{"references":[],"title":"Efficient parallel stencil convolution in Haskell","links":["http://benl.ouroborus.net/papers/2011-stencil/stencil-haskell2011.pdf"]}],[91,{"references":[],"title":"Elaborating evaluation-order polymorphism","links":[]}],[51,{"references":[],"title":"Elaborator reflection: extending Idris in Idris","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951932"]}],[52,{"references":[],"title":"Embedding foreign code","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-ffi-padl2014.pdf"]}],[53,{"references":[],"title":"Experience report: growing and shrinking polygons for random testing of computational geometry algorithms","links":["http://ilyasergey.net/papers/polygons-icfp16.pdf"]}],[92,{"references":[],"title":"Exploiting vector instructions with generalized stream fusion","links":[]}],[54,{"references":[],"title":"Farms, pipes, streams and reforestation: reasoning about structured parallel processes using types and hylomorphisms","links":["https://research-repository.st-andrews.ac.uk/bitstream/handle/10023/9810/Castro_2016_Farms_ICFP2016_AAM.pdf"]}],[55,{"references":[],"title":"Faster coroutine pipelines","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110249"]}],[56,{"references":[],"title":"Faster laziness using dynamic pointer tagging","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2007/10/ptr-tagging.pdf"]}],[93,{"references":[],"title":"Flexible type analysis","links":[]}],[57,{"references":[],"title":"Formally proving a compiler transformation safe","links":["http://www.joachim-breitner.de/publications/CallArity-Haskell15.pdf"]}],[58,{"references":[],"title":"Foundations of strong call by need","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110264"]}],[94,{"references":[],"title":"From System F to typed assembly language","links":[]}],[59,{"references":[],"title":"Fully abstract compilation via universal embedding","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951941"]}],[60,{"references":[],"title":"Functional array streams","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-seq-fhpc2015.pdf"]}],[61,{"references":[],"title":"Generalizing monads to arrows","links":["http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf"]}],[62,{"references":[],"title":"Generic functional parallel algorithms: scan and FFT","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110251"]}],[63,{"references":[],"title":"Generic programming for indexed datatypes","links":["http://dreixel.net/research/pdf/gpid.pdf"]}],[64,{"references":[],"title":"Ghostbuster: a tool for simplifying and converting GADTs","links":["http://www.cs.ox.ac.uk/people/timothy.zakian/ghostbuster.pdf"]}],[95,{"references":[],"title":"Giving Haskell a promotion","links":[]}],[65,{"references":[],"title":"Gradual session types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110282"]}],[66,{"references":[],"title":"Gradual typing with union and intersection types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110285"]}],[67,{"references":[],"title":"Guiding parallel array fusion with indexed types","links":["http://benl.ouroborus.net/papers/2012-guiding/guiding-Haskell2012.pdf"]}],[68,{"references":[],"title":"Hat-Delta: one right does make a wrong","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[69,{"references":[],"title":"Hat-Explore: source-based trace exploration","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[70,{"references":[],"title":"Herbarium Racketensis: a stroll through the woods","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110245"]}],[71,{"references":[],"title":"Hierarchical memory management for parallel programs","links":["http://www.cs.cmu.edu/~rraghuna/publications/icfp-2016-hierarchical-memory-management-for-parallel-programs/paper.pdf"]}],[72,{"references":[],"title":"Higher-order + polymorphic = reusable","links":["https://kar.kent.ac.uk/21504/3/Higher-order_+_Polymorphic_=_Reusable.pdf"]}],[73,{"references":[],"title":"Higher-order ghost state","links":["https://people.mpi-sws.org/~dreyer/papers/hogs/paper.pdf"]}],[74,{"references":[],"title":"Hoogle overview","links":["https://ndmitchell.com/downloads/paper-hoogle_overview-19_nov_2008.pdf"]}],[75,{"references":[],"title":"How to mace ad-hoc polymorphism less ad-hoc","links":["https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf"]}],[96,{"references":[],"title":"How to make ad-hoc polymorphism less ad-hoc","links":[]}],[76,{"references":[],"title":"How to prove your calculus is decidable: practical applications of second-order algebraic theories and computation","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110266"]}],[77,{"references":[],"title":"Imperative functional programming","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf"]}],[78,{"references":[],"title":"Imperative functional programs that explain their work","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110258"]}],[79,{"references":[],"title":"Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf"]}],[80,{"references":[],"title":"Indexed codata types","links":["http://www.cs.mcgill.ca/~bpientka/papers/indexed_codata.pdf"]}],[81,{"references":[],"title":"Inferring scope through syntactic sugar","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110288"]}],[97,{"references":[],"title":"Java generics and collections: speed up the Java development process","links":[]}],[82,{"references":[],"title":"Kami: a platform for high-level parametric hardware specification and its modular verification","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110268"]}],[83,{"references":[],"title":"Lazy evaluation: from natural semantics to a machine-checked compiler transformation","links":["https://www.ksp.kit.edu/download/1000056002"]}],[114,{"references":[],"title":"Let-foating: moving bindings to give faster programs","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/1996/05/float.pdf"]}],[84,{"references":[85,86,87,88,89,39,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111],"title":"Levity polymorphism","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-pldi17.pdf"]}],[112,{"references":[],"title":"Local refinement typing","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110270"]}],[113,{"references":[],"title":"Lock-step simulation is child's play","links":["https://www.joachim-breitner.de/publications/CodeWorld-ICFP17.pdf","https://dl.acm.org/citation.cfm?doid=3136534.3110247"]}],[115,{"references":[],"title":"Losing functions without gaining data: another look at defunctionalization","links":["https://ndmitchell.com/downloads/paper-losing_functions_without_gaining_data-03_sep_2009.pdf"]}],[116,{"references":[],"title":"Machine fusion","links":["http://benl.ouroborus.net/papers/2017-merges/merges-PPDP2017-final.pdf"]}],[117,{"references":[],"title":"Manifest sharing with session types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110281"]}],[118,{"references":[],"title":"Modular, higher-order cardinality analysis in theory and practice","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf"]}],[119,{"references":[],"title":"Monad transformers and modular interpreters","links":["http://haskell.cs.yale.edu/wp-content/uploads/2011/02/POPL96-Modular-interpreters.pdf"]}],[120,{"references":[],"title":"Monads for functional programming","links":["http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf"]}],[121,{"references":[],"title":"No-brainer CPS conversion","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110267"]}],[122,{"references":[],"title":"Non-recursive make considered harmful","links":["https://ndmitchell.com/downloads/paper-non_recursive_make_considered_harmful-22_sep_2016.pdf"]}],[123,{"references":[],"title":"Normalization by evaluation for sized dependent types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110277"]}],[124,{"references":[],"title":"Not all patterns, but enough","links":["https://ndmitchell.com/downloads/paper-not_all_patterns_but_enough-25_sep_2008.pdf"]}],[125,{"references":[],"title":"Oh Lord, please don't let contracts be misunderstood (functional pearl)","links":["https://www2.ccs.neu.edu/racket/pubs/icfp16-dnff.pdf"]}],[126,{"references":[],"title":"On polymorphic gradual typing","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110284"]}],[127,{"references":[],"title":"On the expressive power of user-defined effects: effect handlers, monadic reflection, delimited control","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110257"]}],[128,{"references":[],"title":"Optimising purely functional GPU programs","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-optim-icfp2013.pdf"]}],[129,{"references":[],"title":"Parametric quantifiers for dependent type theory","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110276"]}],[130,{"references":[],"title":"Partial type equivalences for verified dependent interoperability","links":["https://pleiad.cl/papers/2016/dagandAl-icfp2016.pdf"]}],[131,{"references":[],"title":"Persistence for the masses: RRB-vectors in a systems language","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110260"]}],[98,{"references":[],"title":"Polymorphic type schemes and recursive definitions","links":[]}],[99,{"references":[],"title":"Practical type inference for arbitrary-rank types","links":[]}],[132,{"references":[],"title":"Project H: programming R in Haskell","links":["https://ifl2014.github.io/submissions/ifl2014_submission_16.pdf"]}],[133,{"references":[],"title":"Promoting functions to type families in Haskell","links":["https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1000&context=compsci_pubs"]}],[134,{"references":[],"title":"Prototyping a query compiler using Coq","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110253"]}],[100,{"references":[],"title":"Putting type annotations to work","links":[]}],[101,{"references":[],"title":"Quantified types in an imperative language","links":[]}],[135,{"references":[],"title":"Queueing and glueing for optimal partitioning (functional pearl)","links":["http://www.iis.sinica.edu.tw/~scm/pub/queueing-glueing.pdf"]}],[136,{"references":[],"title":"Refinement through restraint: bringing down the cost of verification","links":["https://people.mpi-inf.mpg.de/~crizkall/Publications/cogent.pdf"]}],[137,{"references":[],"title":"Regular, shape-polymorphic, parallel arrays in Haskell","links":["http://benl.ouroborus.net/papers/2010-rarrays/repa-icfp2010.pdf"]}],[138,{"references":[],"title":"Rethinking supercompilation","links":["https://ndmitchell.com/downloads/paper-rethinking_supercompilation-29_sep_2010.pdf"]}],[139,{"references":[],"title":"Retrofitting linear types","links":["https://github.com/tweag/linear-types/releases/download/v2.0/hlt.pdf"]}],[140,{"references":[],"title":"Safe zero-cost coercions for Haskell","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf"]}],[141,{"references":[],"title":"Scaling up functional programming education: under the hood of the OCaml MOOC","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110248"]}],[102,{"references":[],"title":"Scrap your boilerplate: a practical design pattern for generic programming","links":[]}],[142,{"references":[],"title":"Secrets of the Glasgow Haskell Compiler inliner","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf"]}],[143,{"references":[],"title":"Securing concurrent lazy programs against information leakage","links":["https://www.joachim-breitner.de/publications/lazydup_CSF2017_extended.pdf"]}],[144,{"references":[],"title":"Sequent calculus as a compiler intermediate language","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951931"]}],[145,{"references":[],"title":"Set-theoretic types for polymorphic variants","links":["https://www.irif.fr/~gc/papers/icfp16.pdf"]}],[146,{"references":[],"title":"Shake before building: replacing Make with Haskell","links":["https://ndmitchell.com/downloads/paper-shake_before_building-10_sep_2012.pdf"]}],[147,{"references":[],"title":"SHErrLOC: A Static Holistic Error Locator","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2017/08/sherrloc-toplas.pdf"]}],[148,{"references":[],"title":"SpaceSearch: a library for building and verifying solver-aided tools","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110269"]}],[149,{"references":[],"title":"Staged generic programming","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110273"]}],[150,{"references":[],"title":"Story and history: a value-based view of Hat traces","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[151,{"references":[],"title":"Stream fusion: practical shortcut fusion for coinductive sequence types","links":["http://community.haskell.org/~duncan/thesis.pdf"]}],[152,{"references":[],"title":"Streaming irregular arrays","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-seq2-haskell2017.pdf"]}],[153,{"references":[],"title":"String diagrams for free monads (functional pearl)","links":["https://lirias.kuleuven.be/bitstream/123456789/547211/1/free-strings.pdf"]}],[154,{"references":[],"title":"Super 8 languages for making movies","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110274"]}],[155,{"references":[],"title":"Supero: making Haskell faster","links":["https://ndmitchell.com/downloads/paper-supero_making_haskell_faster-27_sep_2007.pdf"]}],[156,{"references":[],"title":"Symbolic conditioning of arrays in probabilistic programs","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110255"]}],[103,{"references":[],"title":"System F with type equality coercions","links":[]}],[104,{"references":[],"title":"System FC with explicit kind equality","links":[]}],[157,{"references":[],"title":"Tackling the testing migration problem with SAT-solvers","links":["https://arxiv.org/pdf/1204.2974.pdf"]}],[158,{"references":[],"title":"Talking bananas: structural recursion for session types","links":["http://homepages.inf.ed.ac.uk/slindley/papers/talking-bananas.pdf"]}],[159,{"references":[],"title":"Testing and debugging functional reactive programming","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110246"]}],[160,{"references":[],"title":"The best of both worlds: linear functional programming without compromise","links":["https://arxiv.org/pdf/1612.06633.pdf"]}],[105,{"references":[],"title":"The essence of compiling with continuations","links":[]}],[161,{"references":[],"title":"The essence of functional programming","links":["https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf"]}],[162,{"references":[],"title":"The expression problem","links":["http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt"]}],[163,{"references":[],"title":"The Hat G-Machine","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[165,{"references":[],"title":"Theorems for free for free: parametricity, with and without types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110283"]}],[164,{"references":[],"title":"Theorems for free!","links":["https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf","http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf"]}],[166,{"references":[],"title":"Think like a vertex, behave like a function! a functional DSL for vertex-centric big graph processing","links":["http://research.nii.ac.jp/~hu/pub/icfp16.pdf"]}],[106,{"references":[],"title":"TIL: A type-directed optimizing compiler for ML","links":[]}],[107,{"references":[],"title":"Toward a foundational typed assembly language","links":[]}],[108,{"references":[],"title":"Towards a theory of type structure","links":[]}],[49,{"references":[],"title":"Towards Haskell in the cloud","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/remote.pdf"]}],[167,{"references":[],"title":"Transformation and analysis of functional programs","links":["https://ndmitchell.com/downloads/paper-transformation_and_analysis_of_functional_programs-4_jun_2008.pdf"]}],[109,{"references":[],"title":"Type classes in haskell","links":[]}],[168,{"references":[],"title":"Type-and-scope safe programs and their proofs","links":["https://gallais.github.io/pdf/cpp2017.pdf"]}],[169,{"references":[],"title":"Type-level web APIs with servant","links":["https://dl.acm.org/authorize?N08939"]}],[170,{"references":[],"title":"Type-safe runtime code generation: Accelerate to LLVM","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-llvm-haskell2015.pdf"]}],[110,{"references":[],"title":"Unboxed values as first class citizens","links":[]}],[171,{"references":[],"title":"Unfailing Haskell","links":["https://ndmitchell.com/downloads/paper-qualifying_dissertation-30_jun_2005.pdf"]}],[172,{"references":[],"title":"Unfailing Haskell: a static checker for pattern matching","links":["https://ndmitchell.com/downloads/paper-unfailing_haskell_a_static_checker_for_pattern_matching-24_sep_2005.pdf"]}],[173,{"references":[],"title":"Unifiers as equivalences: proof-relevant unification of dependently typed data","links":[]}],[174,{"references":[],"title":"Uniform boilerplate and list processing","links":["https://ndmitchell.com/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf"]}],[175,{"references":[],"title":"Using trace data to diagnose non-termination errors","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[176,{"references":[],"title":"Verified low-level programming embedded in F*","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110261"]}],[177,{"references":[],"title":"Verifying efficient function calls in CakeML","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110262"]}],[178,{"references":[],"title":"Visitors unchained","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110272"]}],[179,{"references":[],"title":"Visual Hat","links":["https://ndmitchell.com/downloads/paper-hatday-28_oct_2005.pdf"]}],[180,{"references":[],"title":"Visual theorem proving with the Incredible Proof Machine","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf"]}],[181,{"references":[],"title":"Whip: higher-order contracts for modern services","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110280"]}],[111,{"references":[],"title":"Whole-program compilation in MLton","links":[]}],[182,{"references":[],"title":"Why functional programming matters","links":["https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf"]}],[183,{"references":[],"title":"Yhc.Core: from Haskell to Core","links":["https://ndmitchell.com/downloads/paper-yhc_core-30_apr_2007.pdf"]}]]