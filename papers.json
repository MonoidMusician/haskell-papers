[[0,{"references":[],"name":"A framework for adaptive differential privacy","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110254"]}],[1,{"references":[],"name":"A history of Haskell: being lazy with class","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf"]}],[2,{"references":[],"name":"A metaprogramming framework for formal verification","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110278"]}],[3,{"references":[],"name":"A pretty but not greedy printer","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110250"]}],[4,{"references":[],"name":"A relational logic for higher-order programs","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110265"]}],[5,{"references":[],"name":"A specification for dependent types in Haskell","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110275"]}],[6,{"references":[],"name":"A unified approach to solving seven programming problems","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110252"]}],[7,{"references":[],"name":"Abstracting definitional interpreters","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110256"]}],[8,{"references":[],"name":"Accelerating Haskell array codes with multicore GPUs","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-cuda-damp2011.pdf"]}],[9,{"references":[],"name":"Automating sized-type inference for complexity analysis","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110287"]}],[10,{"references":[],"name":"Better living through operational semantics: an optimizing compiler for radio protocols","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110263"]}],[11,{"references":[],"name":"Call arity","links":["https://www.joachim-breitner.de/publications/CallArity-TFP.pdf"]}],[12,{"references":[],"name":"Chaperone contracts for higher-order sessions","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110279"]}],[13,{"references":[],"name":"Communicating Haskell processes: composable explicit concurrency using monads","links":["http://twistedsquare.com/CHP.pdf"]}],[14,{"references":[],"name":"Compiling to categories","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110271"]}],[15,{"references":[],"name":"Compiling tree transforms to operate on packed representations","links":["http://drops.dagstuhl.de/opus/volltexte/2017/7273/pdf/LIPIcs-ECOOP-2017-26.pdf"]}],[16,{"references":[],"name":"Constrained type families","links":["https://arxiv.org/pdf/1706.09715.pdf","https://dl.acm.org/citation.cfm?doid=3136534.3110286"]}],[17,{"references":[],"name":"Control flow in functional languages","links":["http://www.joachim-breitner.de/various/SA/ShiversStudienarbeit.pdf"]}],[18,{"references":[],"name":"Converting data-parallelism to tasl-parallelism by rewrites","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-multidev-fhpc2015.pdf"]}],[19,{"references":[],"name":"Data flow fusion with series expressions in Haskell","links":["http://benl.ouroborus.net/papers/2013-series/flow-Haskell2013-rev1.pdf"]}],[20,{"references":[],"name":"Dependent Types in Haskell: Theory and Practice","links":["https://arxiv.org/pdf/1610.07978.pdf"]}],[21,{"references":[],"name":"dup â€“ explicit un-sharing in Haskell","links":["https://arxiv.org/pdf/1207.2017.pdf"]}],[22,{"references":[],"name":"Effect-driven QuickChecking of compilers","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110259"]}],[23,{"references":[24],"name":"Efficient communication and collection with compact normal forms","links":["http://ezyang.com/papers/ezyang15-cnf.pdf"]}],[24,{"references":[],"name":"Towards Haskell in the Cloud","links":[]}],[25,{"references":[],"name":"Efficient parallel stencil convolution in Haskell","links":["http://benl.ouroborus.net/papers/2011-stencil/stencil-haskell2011.pdf"]}],[26,{"references":[],"name":"Embedding foreign code","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-ffi-padl2014.pdf"]}],[27,{"references":[],"name":"Faster coroutine pipelines","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110249"]}],[28,{"references":[],"name":"Faster laziness using dynamic pointer tagging","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2007/10/ptr-tagging.pdf"]}],[29,{"references":[],"name":"Formally proving a compiler transformation safe","links":["http://www.joachim-breitner.de/publications/CallArity-Haskell15.pdf"]}],[30,{"references":[],"name":"Foundations of strong call by need","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110264"]}],[31,{"references":[],"name":"Functional array streams","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-seq-fhpc2015.pdf"]}],[32,{"references":[],"name":"Generalizing monads to arrows","links":["http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf"]}],[33,{"references":[],"name":"Generic functional parallel algorithms: scan and FFT","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110251"]}],[34,{"references":[],"name":"Generic programming for indexed datatypes","links":["http://dreixel.net/research/pdf/gpid.pdf"]}],[35,{"references":[],"name":"Ghostbuster: a tool for simplifying and converting GADTs","links":["http://www.cs.ox.ac.uk/people/timothy.zakian/ghostbuster.pdf"]}],[36,{"references":[],"name":"Gradual session types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110282"]}],[37,{"references":[],"name":"Gradual typing with union and intersection types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110285"]}],[38,{"references":[],"name":"Guiding parallel array fusion with indexed types","links":["http://benl.ouroborus.net/papers/2012-guiding/guiding-Haskell2012.pdf"]}],[39,{"references":[],"name":"Herbarium Racketensis: a stroll through the woods","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110245"]}],[40,{"references":[],"name":"Higher-order + polymorphic = reusable","links":["https://kar.kent.ac.uk/21504/3/Higher-order_+_Polymorphic_=_Reusable.pdf"]}],[41,{"references":[],"name":"How to prove your calculus is decidable: practical applications of second-order algebraic theories and computation","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110266"]}],[42,{"references":[],"name":"Imperative functional programs that explain their work","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110258"]}],[43,{"references":[],"name":"Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf"]}],[44,{"references":[],"name":"Inferring scope through syntactic sugar","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110288"]}],[45,{"references":[],"name":"Kami: a platform for high-level parametric hardware specification and its modular verification","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110268"]}],[46,{"references":[],"name":"Lazy evaluation: from natural semantics to a machine-checked compiler transformation","links":["https://www.ksp.kit.edu/download/1000056002"]}],[47,{"references":[48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75],"name":"Levity polymorphism","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-pldi17.pdf"]}],[48,{"references":[],"name":"A reflection on types","links":[]}],[49,{"references":[],"name":"A safe dialect of C","links":[]}],[50,{"references":[],"name":"A transformation-based optimiser for Haskell","links":[]}],[51,{"references":[],"name":"Automating ad hoc representation transformations","links":[]}],[52,{"references":[],"name":"Calling Hell from Heaven and Heaven from Hell","links":[]}],[53,{"references":[],"name":"Dependent types in Haskell: theory and practice","links":[]}],[54,{"references":[],"name":"Design and implementation of generics for the .NET Common Language Runtime","links":[]}],[55,{"references":[],"name":"Elaborating evaluation-order polymorphism","links":[]}],[56,{"references":[],"name":"Exploiting vector instructions with generalized stream fusion","links":[]}],[57,{"references":[],"name":"Flexible type analysis","links":[]}],[58,{"references":[],"name":"From System F to typed assembly language","links":[]}],[59,{"references":[],"name":"Giving Haskell a promotion","links":[]}],[60,{"references":[],"name":"How to make ad-hoc polymorphism less ad-hoc","links":[]}],[61,{"references":[],"name":"Java generics and collections: speed up the Java development process","links":[]}],[62,{"references":[],"name":"Polymorphic type schemes and recursive definitions","links":[]}],[63,{"references":[],"name":"Practical type inference for arbitrary-rank types","links":[]}],[64,{"references":[],"name":"Putting type annotations to work","links":[]}],[65,{"references":[],"name":"Quantified types in an imperative language","links":[]}],[66,{"references":[],"name":"Scrap your boilerplate: a practical design pattern for generic programming","links":[]}],[67,{"references":[],"name":"System F with type equality coercions","links":[]}],[68,{"references":[],"name":"System FC with explicit kind equality","links":[]}],[69,{"references":[],"name":"The essence of compiling with continuations","links":[]}],[70,{"references":[],"name":"TIL: A type-directed optimizing compiler for ML","links":[]}],[71,{"references":[],"name":"Toward a foundational typed assembly language","links":[]}],[72,{"references":[],"name":"Towards a theory of type structure","links":[]}],[73,{"references":[],"name":"Type classes in haskell","links":[]}],[74,{"references":[],"name":"Unboxed values as first class citizens","links":[]}],[75,{"references":[],"name":"Whole-program compilation in MLton","links":[]}],[76,{"references":[],"name":"Local refinement typing","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110270"]}],[77,{"references":[],"name":"Lock-step simulation is child's play","links":["https://www.joachim-breitner.de/publications/CodeWorld-ICFP17.pdf","https://dl.acm.org/citation.cfm?doid=3136534.3110247"]}],[78,{"references":[],"name":"Let-foating: moving bindings to give faster programs","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/1996/05/float.pdf"]}],[79,{"references":[],"name":"Machine fusion","links":["http://benl.ouroborus.net/papers/2017-merges/merges-PPDP2017-final.pdf"]}],[80,{"references":[],"name":"Manifest sharing with session types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110281"]}],[81,{"references":[],"name":"Modular, higher-order cardinality analysis in theory and practice","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf"]}],[82,{"references":[],"name":"No-brainer CPS conversion","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110267"]}],[83,{"references":[],"name":"Normalization by evaluation for sized dependent types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110277"]}],[84,{"references":[],"name":"On polymorphic gradual typing","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110284"]}],[85,{"references":[],"name":"On the expressive power of user-defined effects: effect handlers, monadic reflection, delimited control","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110257"]}],[86,{"references":[],"name":"Optimising purely functional GPU programs","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-optim-icfp2013.pdf"]}],[87,{"references":[],"name":"Parametric quantifiers for dependent type theory","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110276"]}],[88,{"references":[],"name":"Persistence for the masses: RRB-vectors in a systems language","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110260"]}],[89,{"references":[],"name":"Project H: programming R in Haskell","links":["https://ifl2014.github.io/submissions/ifl2014_submission_16.pdf"]}],[90,{"references":[],"name":"Promoting functions to type families in Haskell","links":["https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1000&context=compsci_pubs"]}],[91,{"references":[],"name":"Prototyping a query compiler using Coq","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110253"]}],[92,{"references":[],"name":"Regular, shape-polymorphic, parallel arrays in Haskell","links":["http://benl.ouroborus.net/papers/2010-rarrays/repa-icfp2010.pdf"]}],[93,{"references":[],"name":"Retrofitting linear types","links":["https://github.com/tweag/linear-types/releases/download/v2.0/hlt.pdf"]}],[94,{"references":[],"name":"Safe zero-cost coercions for Haskell","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf"]}],[95,{"references":[],"name":"Scaling up functional programming education: under the hood of the OCaml MOOC","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110248"]}],[96,{"references":[],"name":"Secrets of the Glasgow Haskell Compiler inliner","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf"]}],[97,{"references":[],"name":"Securing concurrent lazy programs against information leakage","links":["https://www.joachim-breitner.de/publications/lazydup_CSF2017_extended.pdf"]}],[98,{"references":[],"name":"SHErrLOC: A Static Holistic Error Locator","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2017/08/sherrloc-toplas.pdf"]}],[99,{"references":[],"name":"SpaceSearch: a library for building and verifying solver-aided tools","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110269"]}],[100,{"references":[],"name":"Staged generic programming","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110273"]}],[101,{"references":[],"name":"Stream fusion: practical shortcut fusion for coinductive sequence types","links":["http://community.haskell.org/~duncan/thesis.pdf"]}],[102,{"references":[],"name":"Streaming irregular arrays","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-seq2-haskell2017.pdf"]}],[103,{"references":[],"name":"Super 8 languages for making movies","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110274"]}],[104,{"references":[],"name":"Symbolic conditioning of arrays in probabilistic programs","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110255"]}],[105,{"references":[],"name":"Tackling the testing migration problem with SAT-solvers","links":["https://arxiv.org/pdf/1204.2974.pdf"]}],[106,{"references":[],"name":"Testing and debugging functional reactive programming","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110246"]}],[107,{"references":[],"name":"The expression problem","links":["http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt"]}],[108,{"references":[],"name":"Theorems for free for free: parametricity, with and without types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110283"]}],[109,{"references":[],"name":"Towards Haskell in the cloud","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/remote.pdf"]}],[110,{"references":[],"name":"Type-and-scope safe programs and their proofs","links":["https://gallais.github.io/pdf/cpp2017.pdf"]}],[111,{"references":[],"name":"Type-level web APIs with servant","links":["https://dl.acm.org/authorize?N08939"]}],[112,{"references":[],"name":"Type-safe runtime code generation: Accelerate to LLVM","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-llvm-haskell2015.pdf"]}],[113,{"references":[],"name":"Verified low-level programming embedded in F*","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110261"]}],[114,{"references":[],"name":"Verifying efficient function calls in CakeML","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110262"]}],[115,{"references":[],"name":"Visitors unchained","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110272"]}],[116,{"references":[],"name":"Visual theorem proving with the Incredible Proof Machine","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf"]}],[117,{"references":[],"name":"Whip: higher-order contracts for modern services","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110280"]}],[118,{"references":[],"name":"Why functional programming matters","links":["https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf"]}]]