[[0,{"references":[],"name":"A framework for adaptive differential privacy","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110254"]}],[1,{"references":[],"name":"A fully concurrent garbage collector for functional programs on multicore processors","links":["http://www.pllab.riec.tohoku.ac.jp/papers/icfp2016UenoOhori-preprint.pdf"]}],[2,{"references":[],"name":"A glimpse of Hopjs","links":["https://hal.inria.fr/hal-01350936/document"]}],[3,{"references":[],"name":"A history of Haskell: being lazy with class","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf"]}],[4,{"references":[],"name":"A lambda-calculus foundation for universal probabilistic programming","links":["https://pps2016.soic.indiana.edu/files/2016/01/lcfupp.pdf"]}],[5,{"references":[],"name":"A metaprogramming framework for formal verification","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110278"]}],[7,{"references":[],"name":"A new verified compiler backend for CakeML","links":["https://cakeml.org/icfp16.pdf"]}],[6,{"references":[],"name":"A pretty but not greedy printer","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110250"]}],[73,{"references":[],"name":"A reflection on types","links":[]}],[8,{"references":[],"name":"A relational logic for higher-order programs","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110265"]}],[74,{"references":[],"name":"A safe dialect of C","links":[]}],[9,{"references":[],"name":"A specification for dependent types in Haskell","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110275"]}],[75,{"references":[],"name":"A transformation-based optimiser for Haskell","links":[]}],[10,{"references":[],"name":"A type theory for incremental computational complexity with control flow changes","links":["https://people.mpi-sws.org/~ecicek/DuCostIt.pdf"]}],[11,{"references":[],"name":"A unified approach to solving seven programming problems","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110252"]}],[12,{"references":[],"name":"Abstracting definitional interpreters","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110256"]}],[13,{"references":[],"name":"Accelerating Haskell array codes with multicore GPUs","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-cuda-damp2011.pdf"]}],[14,{"references":[],"name":"All sorts of permutations","links":["https://www.informatik.uni-kiel.de//~sad/icfp2016-preprint.pdf"]}],[15,{"references":[],"name":"Allocation characterizes polyvariance: a unified methodology for polyvariant control-flow analysis","links":["https://thomas.gilray.org/pdf/allocation-polyvariance.pdf"]}],[16,{"references":[],"name":"An abstract memory functor for verified C static analyzers","links":["https://hal.inria.fr/hal-01339969/document"]}],[17,{"references":[],"name":"Automatically disproving fair termination of higher-order functional programs","links":[]}],[76,{"references":[],"name":"Automating ad hoc representation transformations","links":[]}],[18,{"references":[],"name":"Automating sized-type inference for complexity analysis","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110287"]}],[19,{"references":[],"name":"Better living through operational semantics: an optimizing compiler for radio protocols","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110263"]}],[20,{"references":[],"name":"Call arity","links":["https://www.joachim-breitner.de/publications/CallArity-TFP.pdf"]}],[77,{"references":[],"name":"Calling Hell from Heaven and Heaven from Hell","links":[]}],[21,{"references":[],"name":"Chaperone contracts for higher-order sessions","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110279"]}],[22,{"references":[],"name":"Combining effects and coeffects via grading","links":["https://www.cs.kent.ac.uk/people/staff/dao7/publ/combining-effects-and-coeffects-icfp16.pdf"]}],[23,{"references":[],"name":"Communicating Haskell processes: composable explicit concurrency using monads","links":["http://twistedsquare.com/CHP.pdf"]}],[24,{"references":[],"name":"Compact bit encoding schemes for simply-typed lambda-terms","links":[]}],[25,{"references":[],"name":"Compiling to categories","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110271"]}],[26,{"references":[],"name":"Compiling tree transforms to operate on packed representations","links":["http://drops.dagstuhl.de/opus/volltexte/2017/7273/pdf/LIPIcs-ECOOP-2017-26.pdf"]}],[27,{"references":[],"name":"Constrained type families","links":["https://arxiv.org/pdf/1706.09715.pdf","https://dl.acm.org/citation.cfm?doid=3136534.3110286"]}],[28,{"references":[],"name":"Constructive Galois connections: taming the Galois connection framework for mechanized metatheory","links":["https://arxiv.org/pdf/1511.06965.pdf"]}],[29,{"references":[],"name":"Context-free session types","links":["https://www.di.fc.ul.pt/~vv/papers/thiemann.vasconcelos_context-free-session-types.pdf"]}],[30,{"references":[],"name":"Control flow in functional languages","links":["http://www.joachim-breitner.de/various/SA/ShiversStudienarbeit.pdf"]}],[31,{"references":[],"name":"Converting data-parallelism to tasl-parallelism by rewrites","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-multidev-fhpc2015.pdf"]}],[32,{"references":[],"name":"Dag-calculus: a calculus for parallel computation","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951946"]}],[33,{"references":[],"name":"Data flow fusion with series expressions in Haskell","links":["http://benl.ouroborus.net/papers/2013-series/flow-Haskell2013-rev1.pdf"]}],[34,{"references":[],"name":"Datafun: a functional Datalog","links":["https://www.cl.cam.ac.uk/~nk480/datafun.pdf"]}],[35,{"references":[],"name":"Dependent types in Haskell: theory and practice","links":["https://arxiv.org/pdf/1610.07978.pdf"]}],[36,{"references":[],"name":"Deriving a probability density calculator","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951922"]}],[78,{"references":[],"name":"Design and implementation of generics for the .NET Common Language Runtime","links":[]}],[37,{"references":[],"name":"Disjoint intersection types","links":["http://i.cs.hku.hk/~bruno/papers/icfp2016.pdf"]}],[38,{"references":[],"name":"dup â€“ explicit un-sharing in Haskell","links":["https://arxiv.org/pdf/1207.2017.pdf"]}],[39,{"references":[],"name":"Dynamic witnesses for static type errors (or, ill-typed programs usually go wrong)","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951915"]}],[40,{"references":[],"name":"Effect-driven QuickChecking of compilers","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110259"]}],[41,{"references":[42],"name":"Efficient communication and collection with compact normal forms","links":["http://ezyang.com/papers/ezyang15-cnf.pdf"]}],[43,{"references":[],"name":"Efficient parallel stencil convolution in Haskell","links":["http://benl.ouroborus.net/papers/2011-stencil/stencil-haskell2011.pdf"]}],[79,{"references":[],"name":"Elaborating evaluation-order polymorphism","links":[]}],[44,{"references":[],"name":"Elaborator reflection: extending Idris in Idris","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951932"]}],[45,{"references":[],"name":"Embedding foreign code","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-ffi-padl2014.pdf"]}],[46,{"references":[],"name":"Experience report: growing and shrinking polygons for random testing of computational geometry algorithms","links":["http://ilyasergey.net/papers/polygons-icfp16.pdf"]}],[80,{"references":[],"name":"Exploiting vector instructions with generalized stream fusion","links":[]}],[47,{"references":[],"name":"Farms, pipes, streams and reforestation: reasoning about structured parallel processes using types and hylomorphisms","links":["https://research-repository.st-andrews.ac.uk/bitstream/handle/10023/9810/Castro_2016_Farms_ICFP2016_AAM.pdf"]}],[48,{"references":[],"name":"Faster coroutine pipelines","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110249"]}],[49,{"references":[],"name":"Faster laziness using dynamic pointer tagging","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2007/10/ptr-tagging.pdf"]}],[81,{"references":[],"name":"Flexible type analysis","links":[]}],[50,{"references":[],"name":"Formally proving a compiler transformation safe","links":["http://www.joachim-breitner.de/publications/CallArity-Haskell15.pdf"]}],[51,{"references":[],"name":"Foundations of strong call by need","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110264"]}],[82,{"references":[],"name":"From System F to typed assembly language","links":[]}],[52,{"references":[],"name":"Fully abstract compilation via universal embedding","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951941"]}],[53,{"references":[],"name":"Functional array streams","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-seq-fhpc2015.pdf"]}],[54,{"references":[],"name":"Generalizing monads to arrows","links":["http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf"]}],[55,{"references":[],"name":"Generic functional parallel algorithms: scan and FFT","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110251"]}],[56,{"references":[],"name":"Generic programming for indexed datatypes","links":["http://dreixel.net/research/pdf/gpid.pdf"]}],[57,{"references":[],"name":"Ghostbuster: a tool for simplifying and converting GADTs","links":["http://www.cs.ox.ac.uk/people/timothy.zakian/ghostbuster.pdf"]}],[83,{"references":[],"name":"Giving Haskell a promotion","links":[]}],[58,{"references":[],"name":"Gradual session types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110282"]}],[59,{"references":[],"name":"Gradual typing with union and intersection types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110285"]}],[60,{"references":[],"name":"Guiding parallel array fusion with indexed types","links":["http://benl.ouroborus.net/papers/2012-guiding/guiding-Haskell2012.pdf"]}],[61,{"references":[],"name":"Herbarium Racketensis: a stroll through the woods","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110245"]}],[62,{"references":[],"name":"Hierarchical memory management for parallel programs","links":["http://www.cs.cmu.edu/~rraghuna/publications/icfp-2016-hierarchical-memory-management-for-parallel-programs/paper.pdf"]}],[63,{"references":[],"name":"Higher-order + polymorphic = reusable","links":["https://kar.kent.ac.uk/21504/3/Higher-order_+_Polymorphic_=_Reusable.pdf"]}],[64,{"references":[],"name":"Higher-order ghost state","links":["https://people.mpi-sws.org/~dreyer/papers/hogs/paper.pdf"]}],[84,{"references":[],"name":"How to make ad-hoc polymorphism less ad-hoc","links":[]}],[65,{"references":[],"name":"How to prove your calculus is decidable: practical applications of second-order algebraic theories and computation","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110266"]}],[66,{"references":[],"name":"Imperative functional programs that explain their work","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110258"]}],[67,{"references":[],"name":"Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf"]}],[68,{"references":[],"name":"Indexed codata types","links":["http://www.cs.mcgill.ca/~bpientka/papers/indexed_codata.pdf"]}],[69,{"references":[],"name":"Inferring scope through syntactic sugar","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110288"]}],[85,{"references":[],"name":"Java generics and collections: speed up the Java development process","links":[]}],[70,{"references":[],"name":"Kami: a platform for high-level parametric hardware specification and its modular verification","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110268"]}],[71,{"references":[],"name":"Lazy evaluation: from natural semantics to a machine-checked compiler transformation","links":["https://www.ksp.kit.edu/download/1000056002"]}],[102,{"references":[],"name":"Let-foating: moving bindings to give faster programs","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/1996/05/float.pdf"]}],[72,{"references":[73,74,75,76,77,35,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],"name":"Levity polymorphism","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-pldi17.pdf"]}],[100,{"references":[],"name":"Local refinement typing","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110270"]}],[101,{"references":[],"name":"Lock-step simulation is child's play","links":["https://www.joachim-breitner.de/publications/CodeWorld-ICFP17.pdf","https://dl.acm.org/citation.cfm?doid=3136534.3110247"]}],[103,{"references":[],"name":"Machine fusion","links":["http://benl.ouroborus.net/papers/2017-merges/merges-PPDP2017-final.pdf"]}],[104,{"references":[],"name":"Manifest sharing with session types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110281"]}],[105,{"references":[],"name":"Modular, higher-order cardinality analysis in theory and practice","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf"]}],[106,{"references":[],"name":"No-brainer CPS conversion","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110267"]}],[107,{"references":[],"name":"Normalization by evaluation for sized dependent types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110277"]}],[108,{"references":[],"name":"Oh Lord, please don't let contracts be misunderstood (functional pearl)","links":["https://www2.ccs.neu.edu/racket/pubs/icfp16-dnff.pdf"]}],[109,{"references":[],"name":"On polymorphic gradual typing","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110284"]}],[110,{"references":[],"name":"On the expressive power of user-defined effects: effect handlers, monadic reflection, delimited control","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110257"]}],[111,{"references":[],"name":"Optimising purely functional GPU programs","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-optim-icfp2013.pdf"]}],[112,{"references":[],"name":"Parametric quantifiers for dependent type theory","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110276"]}],[113,{"references":[],"name":"Partial type equivalences for verified dependent interoperability","links":["https://pleiad.cl/papers/2016/dagandAl-icfp2016.pdf"]}],[114,{"references":[],"name":"Persistence for the masses: RRB-vectors in a systems language","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110260"]}],[86,{"references":[],"name":"Polymorphic type schemes and recursive definitions","links":[]}],[87,{"references":[],"name":"Practical type inference for arbitrary-rank types","links":[]}],[115,{"references":[],"name":"Project H: programming R in Haskell","links":["https://ifl2014.github.io/submissions/ifl2014_submission_16.pdf"]}],[116,{"references":[],"name":"Promoting functions to type families in Haskell","links":["https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1000&context=compsci_pubs"]}],[117,{"references":[],"name":"Prototyping a query compiler using Coq","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110253"]}],[88,{"references":[],"name":"Putting type annotations to work","links":[]}],[89,{"references":[],"name":"Quantified types in an imperative language","links":[]}],[118,{"references":[],"name":"Queueing and glueing for optimal partitioning (functional pearl)","links":["http://www.iis.sinica.edu.tw/~scm/pub/queueing-glueing.pdf"]}],[119,{"references":[],"name":"Refinement through restraint: bringing down the cost of verification","links":["https://people.mpi-inf.mpg.de/~crizkall/Publications/cogent.pdf"]}],[120,{"references":[],"name":"Regular, shape-polymorphic, parallel arrays in Haskell","links":["http://benl.ouroborus.net/papers/2010-rarrays/repa-icfp2010.pdf"]}],[121,{"references":[],"name":"Retrofitting linear types","links":["https://github.com/tweag/linear-types/releases/download/v2.0/hlt.pdf"]}],[122,{"references":[],"name":"Safe zero-cost coercions for Haskell","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf"]}],[123,{"references":[],"name":"Scaling up functional programming education: under the hood of the OCaml MOOC","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110248"]}],[90,{"references":[],"name":"Scrap your boilerplate: a practical design pattern for generic programming","links":[]}],[124,{"references":[],"name":"Secrets of the Glasgow Haskell Compiler inliner","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf"]}],[125,{"references":[],"name":"Securing concurrent lazy programs against information leakage","links":["https://www.joachim-breitner.de/publications/lazydup_CSF2017_extended.pdf"]}],[126,{"references":[],"name":"Sequent calculus as a compiler intermediate language","links":["https://dl.acm.org/citation.cfm?doid=2951913.2951931"]}],[127,{"references":[],"name":"Set-theoretic types for polymorphic variants","links":["https://www.irif.fr/~gc/papers/icfp16.pdf"]}],[128,{"references":[],"name":"SHErrLOC: A Static Holistic Error Locator","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2017/08/sherrloc-toplas.pdf"]}],[129,{"references":[],"name":"SpaceSearch: a library for building and verifying solver-aided tools","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110269"]}],[130,{"references":[],"name":"Staged generic programming","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110273"]}],[131,{"references":[],"name":"Stream fusion: practical shortcut fusion for coinductive sequence types","links":["http://community.haskell.org/~duncan/thesis.pdf"]}],[132,{"references":[],"name":"Streaming irregular arrays","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-seq2-haskell2017.pdf"]}],[133,{"references":[],"name":"String diagrams for free monads (functional pearl)","links":["https://lirias.kuleuven.be/bitstream/123456789/547211/1/free-strings.pdf"]}],[134,{"references":[],"name":"Super 8 languages for making movies","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110274"]}],[135,{"references":[],"name":"Symbolic conditioning of arrays in probabilistic programs","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110255"]}],[91,{"references":[],"name":"System F with type equality coercions","links":[]}],[92,{"references":[],"name":"System FC with explicit kind equality","links":[]}],[136,{"references":[],"name":"Tackling the testing migration problem with SAT-solvers","links":["https://arxiv.org/pdf/1204.2974.pdf"]}],[137,{"references":[],"name":"Talking bananas: structural recursion for session types","links":["http://homepages.inf.ed.ac.uk/slindley/papers/talking-bananas.pdf"]}],[138,{"references":[],"name":"Testing and debugging functional reactive programming","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110246"]}],[139,{"references":[],"name":"The best of both worlds: linear functional programming without compromise","links":["https://arxiv.org/pdf/1612.06633.pdf"]}],[93,{"references":[],"name":"The essence of compiling with continuations","links":[]}],[140,{"references":[],"name":"The expression problem","links":["http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt"]}],[141,{"references":[],"name":"Theorems for free for free: parametricity, with and without types","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110283"]}],[142,{"references":[],"name":"Think like a vertex, behave like a function! a functional DSL for vertex-centric big graph processing","links":["http://research.nii.ac.jp/~hu/pub/icfp16.pdf"]}],[94,{"references":[],"name":"TIL: A type-directed optimizing compiler for ML","links":[]}],[95,{"references":[],"name":"Toward a foundational typed assembly language","links":[]}],[96,{"references":[],"name":"Towards a theory of type structure","links":[]}],[42,{"references":[],"name":"Towards Haskell in the cloud","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/remote.pdf"]}],[97,{"references":[],"name":"Type classes in haskell","links":[]}],[143,{"references":[],"name":"Type-and-scope safe programs and their proofs","links":["https://gallais.github.io/pdf/cpp2017.pdf"]}],[144,{"references":[],"name":"Type-level web APIs with servant","links":["https://dl.acm.org/authorize?N08939"]}],[145,{"references":[],"name":"Type-safe runtime code generation: Accelerate to LLVM","links":["https://github.com/AccelerateHS/acceleratehs.github.io/raw/master/papers/acc-llvm-haskell2015.pdf"]}],[98,{"references":[],"name":"Unboxed values as first class citizens","links":[]}],[146,{"references":[],"name":"Unifiers as equivalences: proof-relevant unification of dependently typed data","links":[]}],[147,{"references":[],"name":"Verified low-level programming embedded in F*","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110261"]}],[148,{"references":[],"name":"Verifying efficient function calls in CakeML","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110262"]}],[149,{"references":[],"name":"Visitors unchained","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110272"]}],[150,{"references":[],"name":"Visual theorem proving with the Incredible Proof Machine","links":["https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf"]}],[151,{"references":[],"name":"Whip: higher-order contracts for modern services","links":["https://dl.acm.org/citation.cfm?doid=3136534.3110280"]}],[99,{"references":[],"name":"Whole-program compilation in MLton","links":[]}],[152,{"references":[],"name":"Why functional programming matters","links":["https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf"]}]]